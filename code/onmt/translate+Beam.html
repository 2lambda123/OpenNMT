<p><a name="onmt.Beam.dok"></a></p>

<h2>onmt.Beam</h2>

<p>Class for maintaining statistics of each step. A beam mainly consists of
  a list of tokens <code>tokens</code> and a state <code>state</code>. <code>tokens[t]</code> stores a flat tensor
  of size <code>batchSize * beamSize</code> representing the tokens at step <code>t</code>, while
  <code>state</code> can be either a tensor with first dimension size <code>batchSize * beamSize</code>,
  or an iterable object containing several such tensors.</p>

<p><a name="onmt.Beam"></a></p>

<h3>onmt.Beam(token, state, params, batchSize)</h3>

<p>Constructor. We allow users to either specify all initial hypotheses by
  passing in <code>token</code> and <code>state</code> with first dimension <code>batchSize * beamSize</code>
  such that there are <code>beamSize</code> initial hypotheses for every sequence in the
  batch and pass in the number of sequences <code>batchSize</code>, or only specify one
  hypothesis per sequence by passing <code>token</code> and <code>state</code> with first dimension
  <code>batchSize</code>, and then <code>onmt.translate.BeamSearcher</code> will pad with auxiliary
  hypotheses with scores <code>-inf</code> such that each sequence starts with <code>beamSize</code>
  hypotheses as in the former case.</p>

<p>Parameters:</p>

<ul>
<li><code>token</code> - tensor of size <code>(batchSize, vocabSize)</code> (if start with one initial
hypothesis per sequence) or <code>(batchSize * beamSize, vocabSize)</code> (if start with
<code>beamSize</code> initial hypotheses per sequence), or a list of such tensors.</li>
<li><code>state</code> - an iterable object, where the contained tensors should have the
same first dimension as <code>token</code>.</li>
<li><code>batchSize</code> - optional, number of sentences. Only necessary if
start with <code>beamSize</code> hypotheses per sequence. [<code>token:size(1)</code>]</li>
</ul>

<p><a name="onmt.Beam:getTokens"></a></p>

<h3>onmt.Beam:getTokens()</h3>

<p>Returns:</p>

<ul>
<li><code>tokens</code> - a list of tokens. Note that the start-of-sequence symbols are
also included. <code>tokens[t]</code> stores the tokens at step <code>t</code>, which is a tensor
of size <code>batchSize * beamSize</code>.</li>
</ul>

<p><a name="onmt.Beam:getState"></a></p>

<h3>onmt.Beam:getState()</h3>

<p>Returns:</p>

<ul>
<li><code>state</code> - an abstract iterable object as passed by constructor. Every tensor
inside the <code>state</code> has first dimension <code>batchSize * beamSize</code></li>
</ul>

<p><a name="onmt.Beam:getScores"></a></p>

<h3>onmt.Beam:getScores()</h3>

<p>Returns:</p>

<ul>
<li><code>scores</code> - a flat tensor storing the total scores for each batch. It is of
size <code>batchSize * beamSize</code>.</li>
</ul>

<p><a name="onmt.Beam:getBackPointer"></a></p>

<h3>onmt.Beam:getBackPointer()</h3>

<p>Returns:</p>

<ul>
<li><code>backPointer</code> - a flat tensor storing the backpointers for each batch. It is
of size <code>batchSize * beamSize</code></li>
</ul>

<p><a name="onmt.Beam:getRemaining"></a></p>

<h3>onmt.Beam:getRemaining()</h3>

<p>Returns the number of unfinished sequences. The finished sequences will be
  removed from batch.</p>

<p>Returns:</p>

<ul>
<li><code>remaining</code> - the number of unfinished sequences.</li>
</ul>

<p><a name="onmt.Beam:remaining2Orig"></a></p>

<h3>onmt.Beam:remaining2Orig(remainingId)</h3>

<p>Since finished sequences are being removed from the batch, this function
  provides a way to convert the remaining batch id to the original batch id.</p>

<p><a name="onmt.Beam:orig2Remaining"></a></p>

<h3>onmt.Beam:orig2Remaining(origId)</h3>

<p>Since finished sequences are being removed from the batch, this function
  provides a way to convert the original batch id to the remaining batch id.</p>

<p><a name="onmt.Beam:setState"></a></p>

<h3>onmt.Beam:setState(state)</h3>

<p>Set state.</p>

<p><a name="onmt.Beam:setScores"></a></p>

<h3>onmt.Beam:setScores(scores)</h3>

<p>Set scores.</p>

<p><a name="onmt.Beam:setBackPointer"></a></p>

<h3>onmt.Beam:setBackPointer(backPointer)</h3>

<p>Set backPointer.</p>
